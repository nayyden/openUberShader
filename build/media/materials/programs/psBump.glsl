/*
Пиксел(Фрагмен) шейдър. Изпълнява се веднъж за всеки пиксел(фрагмен).
*/

/* 
 * Константи за брой светлинни 
 * източници
 */
#define MAX_LIGHTS 2
#define NUM_LIGHTS 2

// Масив от вектори които представляват посоката на светлинните източници
varying vec3 lightVec[MAX_LIGHTS];
// Вектор съдържащ координати на точка (от изображение), на които отговаря текущия фрагмент
varying vec2 texCoord;

/* Изображение което съдържа нормалния вектор на обекта, в текущия фрагмент, в локалната координатна система, 
   като координатите (x,y,z) са записани съответно в (r,g,b) каналите на изображението.
   За да е възможно записването на стойности от интервала [-1,1] в каналите (които приемат само [0,1])
   всеки координат е увеличен с 1 и разделен на 2. Тоест в шейдъра трябва да се направи обратното  */
uniform sampler2D normalMap;

/* Този коефициент се използва за да намали/увеличи осветлението в/у обекта.
   Ирае ролята на радиус в който светлината дава отражение.
   Наричаме го инвертиран защото стойност 0,001 означава радиус 1000. */
uniform float inversedRadius;

// Стойност с която озачаваме дали използваме един или повече светлинни източници ( 0 за един, 1 за повече)
uniform int multiLight;

void main (void)
{
	// Инициализация на необходимите променливи
	vec4  final_color = vec4(0.0, 0.0, 0.0, 0.0);
	float att = 0.0;
	

	// От изображението normalMap се извлича нормалата на обекта в текущия фрагмент, 
	// като се взима пиксел от изображението с координатите в texCoord
	vec3 norm =  texture2D(normalMap, texCoord).xyz ;

	/* Правим необходимите преобразования на координатите както е описано по-горе,
	   normalize() връща същия вектор с дължина 1.0  */
	vec3 n = normalize( norm* 2.0 - 1.0);
	
	// Ако имаме само един светлинен източник:
	if(multiLight == 0) {
		// Вертекс шейдърът е подал посоката само на един свтлинен източник
		// Намираме неговия скаларен квадрат
		float distSqr = dot(lightVec[0], lightVec[0]);
		
		/* Намираме силта на осветяване в даден пиксел, както е дефинирана в теорията
		   а чрез clamp() изрязваме стойността между 0 и 1*/
		att = clamp(1.0 - inversedRadius * sqrt(distSqr), 0.0, 1.0);
		vec3 lVec = lightVec[0] * inversesqrt(distSqr);
		
		/* Тъй като glsl може да извлече състоянието на обектите като текущ цвят и т.н., 
		   можем да вземем цветът на светлината и на материала на обекта както са настроени в opengl
		   и да добавим техния ефект към шейдъра. */
		vec4 vAmbient = gl_LightSource[0].ambient * gl_FrontMaterial.ambient;
		
		/* Средният тон на цвета в текущия фрагмент, според посоката на светлината и нормалата в пиксела
		   двата вектора са нормализирани, при което dot() ни дава косинуса на ъгъла м/у двата вектора
		   Ако той е отрицателен го приемаме за 0, тоест светлината там няма да има ефект */
		float diffuse = max( dot(lVec, n), 0.0 );
		
		/* Цветът на обекта както е зададен в opengl се изсветлява/затъмнява според изчисления горе косинус*/ 
		vec4 vDiffuse = gl_FrontMaterial.diffuse * diffuse  ;	
		
		// В последната стъпка прибавяме получения цвят към крайния.
		final_color = vDiffuse + vAmbient;

	// Ако имаме повече от един светлинен източник:
	} else if(multiLight == 1) {
		int   i   = 0.0;
		// Обхождаме всички свтлинни източници. Изчисленията са аналогични.
		for(i = 0; i < NUM_LIGHTS; i++) {
		
			float distSqr = dot(lightVec[i], lightVec[i]);
			att = clamp(1.0 - inversedRadius * sqrt(distSqr), 0.0, 1.0);
			vec3 lVec = lightVec[i] * inversesqrt(distSqr);

			vec4 vAmbient = gl_LightSource[i].ambient * gl_FrontMaterial.ambient;
			
			float diffuse = max( dot(lVec, n), 0.0 );	
			vec4 vDiffuse = gl_FrontMaterial.diffuse * diffuse  ;	
			
			// Всяка светлина прибавя своя ефект към крайния цвят
			final_color += vDiffuse + vAmbient;
		}
	}
    	
	// Изходният цвят. Всеки фрагмент шейдър трябва да запише изходния си цвят в тази променлива.
	gl_FragColor = (final_color ) * att ;
}