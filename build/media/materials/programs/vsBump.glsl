/* Vertex шейдър 
 * Изпълнява се за всяка точка независимо
 */

/* 
 * Константи за брой светлинни 
 * източници
 */
#define NUM_LIGHTS 2
#define MAX_LIGHTS 2

/* 
 * Дефиниции на променливи които 
 * ще бъдат интерполирани между  
 * точките и ще бъдат предадени на 
 * пиксел шейдъра
 */
/* Масив от вектори които представляват посоката на светлинните източници */
varying vec3 lightVec[MAX_LIGHTS];
/* Вектор съдържащ текстурните координати за дадена точка */
varying vec2 texCoord;

/* 
 * Дефиниции на променливи 
 * които се предават като параметри 
 * от потребителската програма.
 */

/* Допирателен вектор еднозначно определен за всяка точка */
attribute vec3 tangent; 

/*
 * Дефиниции на променливи 
 * които се предават като параметри
 * които имат постоянна стойност през
 * цялото изпълнение на шейдъра
 */
/* Цяло число определящо дали има повече от един 
 * светлинен източник.
 * При стойност 0 - само един светлинен източник
 * При стойност 1 - повече от един 
 */
uniform int multiLight;

/* Дефиниция и декларация на главнта функция
 * на вертекс шейдъра 
 */
void main(void)
{       
	/* Задълцителна стъпка необходима за по-нататъшното 
         * обработване на точките от графичния конвйер 
         */
	gl_Position = ftransform();
        
        /* Задаваме стойност на текстурните координати 
         * за обработваната точка
	 */
	texCoord = gl_MultiTexCoord0.xy;
	
	/* Нормализация и трансформация на нормалния вектор
	 * за текущата точка
	 */ 
	vec3 n = normalize(gl_NormalMatrix * gl_Normal);
	
	/* Нормализация и трансформация на допирателния вектор
	 * за текущата точка
	 */ 
	vec3 t = normalize(gl_NormalMatrix * tangent);
	
	/* Изчисление на бинормалния вектор чрез векторно произведение */
	vec3 b = normalize(cross(n, t));

	/* Вектор определящ позицията на текущата точка във сцената */
	vec3 vVertex = vec3(gl_ModelViewMatrix * gl_Vertex);
	
	/* Помощна вектор променлива */
	vec3 tmpVec;
	
	/* Матрица  (3-ти ред),
	 * нужна за трансформация на вектори в
	 * локална  координатна система 
	 */ 
	mat3 TBNMatrix = mat3(t, b, n);
	
	/* Aко имаме само един светлинен източник */
	if(multiLight == 0) {
		/* Изчисляваме посоката на светлинния източник */
		tmpVec = normalize(gl_LightSource[0].position.xyz - vVertex);
		
		/* Трансформация на вектора определящ посоката
		 * на светлинния източник във локалната координатна система
		 * на текущата точка
		 */ 
		lightVec[0] =   tmpVec * TBNMatrix;
		
	} else if (multiLight == 1) { /* Ако имаме повече от един светлинен източник */ 
		int i;
		/* Итерираме през всички светлинни източници в сцената 
		 * като се изчисляват посоките им и се трансформират 
		 * в локалната координатна система на точката
		 */
		for(i = 0; i < NUM_LIGHTS; i++) {
			tmpVec = normalize(gl_LightSource[i].position.xyz - vVertex);		
			lightVec[i] = tmpVec * TBNMatrix;			
		}
	}
		
	
	
}
